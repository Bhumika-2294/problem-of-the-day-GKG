class Solution {
  public:

    int shortestPath(int V, int a, int b, vector<vector<int>> &edges) {
        vector<vector<array<int, 3>>> adj(V);
        int m = edges.size();

        for (int i = 0; i < m; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            int w = edges[i][2];
            int cw = edges[i][3];

            adj[u].push_back({v, w, cw});
            adj[v].push_back({u, w, cw});
        }

        int INF = 1e9;

        vector<vector<int>> dist(V, vector<int>(2, INF));

        // PQ stores state: {distance_so_far, node, usedCurve_flag}
        using State = array<int, 3>;
        priority_queue<State, vector<State>, greater<State>> pq;

        // Start from 'a' without using any curved edge
        dist[a][0] = 0;
        pq.push({0, a, 0});

        while (!pq.empty()) {

            auto cur = pq.top();
            pq.pop();

            int d = cur[0];
            int node = cur[1];
            int used = cur[2];

            // Skip outdated/invalid entries
            if (d != dist[node][used])
                continue;

            // Explore all neighbors of 'node'
            for (auto &it : adj[node]) {
                int nxt = it[0];
                int w1 = it[1];
                int w2 = it[2];

                // Take straight edge - usedCurve remains same
                if (dist[nxt][used] > d + w1) {
                    dist[nxt][used] = d + w1;
                    pq.push({dist[nxt][used], nxt, used});
                }

                // Use curved edge (only if not used before)
                if (used == 0) {
                    if (dist[nxt][1] > d + w2) {
                        dist[nxt][1] = d + w2;
                        pq.push({dist[nxt][1], nxt, 1});
                    }
                }
            }
        }

        // Minimum of both possibilities (curved used or not used)
        int ans = min(dist[b][0], dist[b][1]);

        return ans >= INF ? -1 : ans;
    }
};
